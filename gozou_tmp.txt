第１回 	11/16 	画像フォーマット / 画像の表示 

unsigned char は符号なしなので0~255を格納できる
ちなみにchar が保存できる値は -127～127



fwrite関数は指定バイト数のデータを指定した個数だけファイルに書き込みます。
fwrite(const void *buf, size_t size, size_t n, FILE *fp);

第一引数はデータが入ったバッファ
第二引数はデータ1個のバイト数
第三引数は書き込むデータの個数
第四引数はファイルポインタ
【戻り値】
正常時　：　書き込んだデータ個数（バイトではありません）
エラー時　：　nより小さな値


式１?式２:式３

3項演算というらしい。
式１の結果がTRUEなら式２実行、式３無視。
式１の結果がFALSEなら式３実行、式２無視という動き。
式１の結果は必ずBoolean型でないと駄目。

if(式１){式２}else{式３}と同じとはいいきれない
foo = a == NULL ? 0 : b; は
if(a==NULL){foo=a;}else{foo=b;}みたいな

これは式の優先度の問題。右側が優先されることに注意！！



写真は jpeg, 図はpngが適している？

image.h　はstdio.hとかとは違って独自に作成したものなので同じディレクトリ内に置かなければならない。

//画像をファイルに出力する関数(自作)
void ImageWrite(const char*name,Image*im){



easyprocess.c
は単に処理した後ppmを作成
./a.out a.ppm out.ppm　　　←a.ppmはすでに作ってあるもの

easyprocess_2.c
は単に処理した後ppmとjpgを作成
./a.out a.ppm out 後半は拡張子をつけないことに注意！！
一応コピー　../easyprocess2.c

width 640, height 480







第２回 	11/30 	画像の幾何学変換 / 画像の合成

void ImageWrite_ppm_and_jpeg
は以降void ImageWriteと表記することもある

Image*ImageRead(const char*name)
はppm画像にのみ対応しており、jpgには対応していない


homography.cのために自作する関数
ImageClear(Image*im){}

isInsideImage(Image *is,int u,int v)はimage.hの中でdefine文によって定義されているので作らなくてよい


一応完成
homography.c
はあらかじめdjpegでjpgからppmに変換して、ppmを読み込む必要がある

homography2.cはjpgからでもOKだがプログラム内でjpgをppmに変換してあり、aaaaa.ppmというファイルが作られる
すでにその名前のファイルがあるときは上書きされるので注意

homography2.cは行列bを使っており
homography2_a.cは行列aを使っている




pano0.cは0.jpgと1.jpgを合成するプログラム
ファイル内に0.jpgと1.jpgがあること前提

pano0_2.cとしていろいろいじって作成
system使ってjpgをppmにしたりとか

pano_2.cは行列そのまま
pano_3.cは行列m10と関数mult33を実装

回転とか拡大縮小のやつは上手くいかなかった
拡大はhomography3.c

回転はhomography4.c
と
homography_kaiten.c






[2]の問いについて考察しなさい． 
同一視点から撮影された遠景の画像は， 何らかの射影変換によって重ねあわせることができるが， 正しく重ねあわせるには正しい行列が必要である． 自分で撮影した画像を合成するための行列を算出するには， どのようにすれば良いか？


0.jpg
もとの画像(panoで使う)
幅: 768ピクセル
高さ: 576ピクセル


1.jpg   
もとの画像(homographyで使う)
幅: 768ピクセル
高さ: 576ピクセル



out.jpg  
homographyのもの（ppmじゃないとダメなやつ）
幅: 1024ピクセル
高さ: 768ピクセル


out2.jpg	
homography2のもの(jpeg大丈夫なやつ)
幅: 1024ピクセル
高さ: 768ピクセル


out3.jpg  
homography2_aのもの
幅: 1024ピクセル
高さ: 768ピクセル


out_pano0_2.jpg  
mult33を利用してないもの
幅: 1024ピクセル
高さ: 768ピクセル


out_pano0_3.jpg
mult33を利用したもの
幅: 1024ピクセル
高さ: 768ピクセル






第３回 	12/7 	変換行列の算出 / 最小2乗法 




col-major とrow-major の違いは行列？への入れ方
横に入れているか、たてにいれているか
普通は横に入れるが、今回は縦に入れるものも混ざっている
a[0][0]とa[0][1]はメモリで連続しているがa[1][0]は連続ではない


そのためRowとかでの引数の順番が異なることもある．

mallocしていてfreeはしていないが、今回はしなくてよい
プログラム終了直前のfreeは意味がない

pdfでのa1T a0はa1とa0の内積の事（数学的な書き方）


//最小2乗法で方程式Rx=bを解く（自分で改変）
void MatrixSimeqLr(Matrix*mtB,Matrix*mtR){
  double * B = Row(mtB,0);





lsq.txt に表れる関数の使いかたを理解し， 実際に動くように完成させなさい．

    MatrixDecompはfeatures.pdf内の式(13)からの処理を行う． なお，配列aTも修正する必要があることに注意．
    MatrixSimeqLrはfeatures.pdf内の式(22)の後ろに書いてある後退代入を行う．
    * どのような大きさの行列でも扱えるようにするには，全ての操作を直接書くのではなく，ループを用いて実装する方が良い． ループの回数は行列の行数や列数で決まる． 引数を増やしたりグローバル変数を使用する必要はない．



    プログラムが正しく動作すると，与えられた4組の対応点から，前回の[3]に挙げた行列 m10 が得られる．
        (注) 計算結果tmpは8要素のベクトルであり，そのままでは3x3行列として使うことはできない． 




例示してある特徴点は正確ではないため，あまり品質の良くない行列が得られ，合成結果がずれる．

    ずれをなくすために，新たに正確な4組の座標を与えて実験する．
    このページを使ってマウスカーソルの指す画素の座標を調べることができる．



double m10[][3]={
       0.980063, 0.155844, 98.500361,
      -0.055756, 1.153389, 0.503900,
      -0.000139, 0.000316, 1
    },

VP(double*a,double*b,int N)

void VSS(double*d,double s,int N)

void VSA(double*d,double*a,double s,int N)

void MatrixQRDecompColMajor(Matrix*mtR,Matrix*mt)

void MatrixSimeqLr(Matrix*mtB,Matrix*mtR)





















第４回 	12/14 	特徴点の自動検出 1 


かかった時間は平均値や中央値など何回か行った結果を用いた方がよい

共通の関数やマクロはimage.hに書くといいかも？


gcc TKfilter.c -lm -O3 -mavx2 -march=native -funroll-loops -fomit-frame-pointer


void ImageDrawBox(Image*im,int x,int y)
void ImageMatrixWrite(Image*im,Matrix*mt,double s)
void ImageFeature(Matrix*im2,Image*im)
double mt22_min_eigenvalue(int a,int b, int c, int d)
int MatrixLocalMax(int w[][2], Matrix*im2)


pano_が変？

全て1回めは除いている
これが単純
TKfilter2.c
tk2_out

241.739876 msec

241.570798 msec

241.582958 msec

平均241.63121066666668




これがGPU
TKfilter_GPU2.c  
tk2_GPU_out
putkfilter2.cu



42.444522 msec

44.611525 msec

42.409403 msec

平均43.15515


これがGPU分解
TKfilter_GPU3.c
gputkfilter3.cu
tk3_GPU_out

4.336596 msec

4.335995 msec

4.359617 msec

平均4.34406933333333

gcc -c -O TKfilter_GPU2.c
  768  nvcc -arch=sm_21 TKfilter_GPU2.o gputkfilter2.cu
  769  ./a.out 0.ppm 




Tkfilter2.cのコメントImageDrawBox少し追加

第五回で行うこと少しやってしまってた













第５回 	12/21 	特徴点の自動検出 2

[1]の実装． 

単純
TKfilter3.c
1回目は除く、2回め以降はしたのように
62.594096 msec

62.255812 msec

62.296313 msec

62.251487 msec


分解（未完成）
TKfilter4.c



[2]の実装

（方法1）
クイックソート
TKfilter_qsort.c
まとめてソート
1回目は除く、2回め以降はしたのように
62.087771 msec

62.131029 msec

62.579303 msec

62.188424 msec
maxrss=5328
maxrss=5336
maxrss=5332


getrusage - 資源の使用量を取得する  
getrusage メモリ使用量 maxrssでググる


（方法2）
クイックソート
TKfilter_qsort2.c
N_maxを越える度にソートしなおす
1回目は除く、2回め以降はしたのように
63.357484 msec

63.431026 msec

63.397040 msec

63.338999 msec
maxrss=5296
maxrss=5292
maxrss=5312







(方法2)まだ
挿入ソート
TKfilter_isort.c


(方法2)まだ
ヒープ
TKfilter_heap.c



第６回 	1/18 	貪欲法による自動対応付け 






第７回 	1/25 	RANSACによる自動対応付け 







第８回 	2/1 	まとめ 
最終レポートはreport12_14から要修正
GPUの時間の所、main内で2回ImageFeature呼ぶ
後半だけ時間はかる
